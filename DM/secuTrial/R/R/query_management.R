#' Generate discrepancy list from data frame.
#'
#' This function generates a data frame in the format required for the
#' "Discrepancies Transfer Module (DTM)" of SecuTrial. Input is a subset
#' of the original table for which for all row a query for a specified
#' column shall be raised.
#'
#' @param df data frame typically generated by subset
#' @param df.name name of the original data frame as defined in \code{table.list}
#' @param col.name name of the column to be adressed by the query
#' @param query.id internal identifier of the query cycle
#' @param query.date date of the query (default: today)
#' @param query.text query text (default: Entry not possible.)
#' @param query.instruction instruction for the user (default: Please check entry.)
#' @return The filename as in the SecuTrial export.
#' @export
#' @seealso write.discrepancy.list
generate.discrepancy.list <- function(df, df.name=deparse(substitute(df)), col.name, query.id=1, query.date=format(Sys.Date(), format="%d.%m.%Y"), query.text="Entry not possible.", query.instruction="Please check entry.") {
  query.df <- data.frame(query.id=character(),query.date=character(),table.name=character(),column.name=character(),doc.id=character(),mnppid=character(),query.text=character(),query.instruction=character())
  ## convert table name to long name
  table.list <- get("table.list") # declare variable since defined in dossier lib
  table.name.long <- table.list[[df.name]]$tablename
  for(i in 1:nrow(df)) {
    query.text.current <- query.text
    if(length(query.text) == nrow(df)) query.text.current <- query.text[i]
    query.instruction.current <- query.instruction
    if(length(query.instruction) == nrow(df)) query.instruction.current <- query.instruction[i]
    doc.id <- df[i,"mnpdocid"]
    if("mnpsubdocid" %in% names(df)) doc.id <- df[i,"mnpsubdocid"]
    query.df <- rbind(query.df, data.frame(query.id=query.id, query.date=query.date, table.name=table.name.long, col.name=gsub("\\.", "_",col.name), doc.id=doc.id, mnppid=df[i,"mnppid"], query.text=query.text.current, query.instruction=query.instruction.current))
  }
  query.df
}

# TODO: Warning messages may be formulated more precisely: which part is wrong?

#' Check consistency of raw discrepancy list.
#'
#' This function checks the consistency of the raw discrepancy list received from
#' the customer. Both the consistency of the data types in the data frame as well
#' as the content (i.e. do the table names, column names and doc IDs exist?) is checked.
#'
#' @param df data frame with the raw discrepancy list
#' @param check.datatypes logical whether data types shall be checked (default: TRUE)
#' @param check.content logical whether content shall be checked (default: TRUE)
#' @param verbose show content of each field being queried
#' @return NULL
#' @export
#' @seealso generate.discrepancy.list
check.raw.discrepancy.list <- function(df, check.datatypes=TRUE, check.content=TRUE, verbose=TRUE) {
  ## check data frame structure
  if(check.datatypes == TRUE) stopifnot(all(as.character(sapply(df, class)) == c("factor","factor","integer","integer","factor","factor")) == TRUE)
  ## check table names
  table.list <- get("table.list") # declare variable since defined in dossier lib
  file.list <- as.character(sapply(table.list, FUN = function(x) x$filename))
  if(check.content == TRUE) stopifnot(all(df[,1] %in% file.list))
  ## check col.name, doc.id and mnppid
  for(i in 1:nrow(df)) {
    target.df <- eval(parse(text=names(table.list)[which(sapply(table.list, FUN = function(x) x$filename) == df[i,1])]))
    s <- subset(target.df, mnppid==df[i,4] & mnpdocid==df[i,3])
    if("mnpsubdocid" %in% names(target.df)) s <- subset(target.df, mnppid==df[i,4] & mnpsubdocid==df[i,3])
    if(nrow(s) == 1 & verbose == TRUE) {
      if(as.character(df[i,2]) %in% names(s)) print(paste(df[i,2], s[[as.character(df[i,2])]]))
      else warning(paste("Entry", i, "corrupt: field name", as.character(df[i,2]), "not found."))
    } else warning(paste("Entry", i, "corrupt:", nrow(s), "entries found."))
  }
}

#' Add meta information to discrepancy list from customer.
#'
#' This function adds the necessary meta information to the discrepancy list
#' needed for an import into SecuTrial using the "Discrepancies Transfer Module (DTM)".
#' The original column names are restored by replacing dots by underscores
#' in column names.
#'
#' @param df data frame with the raw discrepancy list
#' @param query.id internal identifier of the query cycle
#' @param query.date date of the query (default: today)
#' @param translate.table.name translate filename to tablename (default: TRUE)
#' @export
#' @seealso generate.discrepancy.list
process.raw.discrepancy.list <- function(df, query.id=1, query.date=format(Sys.Date(), format="%d.%m.%Y"), translate.table.name=TRUE) {
  if (translate.table.name == TRUE) df[,1] <- sapply(df[,1], filename2tablename)
  df$query.id <- query.id
  df$query.date <- query.date
  df <- move.column.after(df, c("query.id", "query.date"), "first")
  df$col.name <- gsub("\\.", "_",df$col.name)
  df
}

## TODO: add function to check raw.discrepancy.list
## e.g. mnpsubdocid used when present, colname existing (generate eCRF dict), ...


#' Write discrepancy list to csv.
#'
#' Simple wrapper to \code{link{write.table}} with row.names=TRUE, col.names=FALSE and sep="\\t".
#' The row.names build the unique identifier needed in the
#' discrepancy list.
#'
#' @param df data frame generate by \code{link{generate.discrepancy.list}}
#' @param file file name for the discrepancy list csv file
#' @return Discrepancy list in tab-separated csv format.
#' @export
#' @seealso generate.discrepancy.list
write.discrepancy.list <- function(df, file) {
  write.table(df, file, row.names=TRUE, col.names=FALSE, sep='\t')
}

## ----------------------------------------------------------------------

#' Convert data frame name to file name.
#'
#' This function converts the internal data frame name as specified in
#' \code{table.list} to the filename in the export ("shorten tables names" enabled).
#' Either the name or the data frame directly is requeried.
#'
#' @param df data frame name or object
#' @return The filename as in the SecuTrial export.
#' @export
#' @seealso table.list, df2tablename, filename2tablename
df2filename <- function(df) {
  table.list <- get("table.list") # declare variable since defined in dossier lib
  ## convert to character if object is provided
  if(typeof(df) != "character") table.name <- deparse(substitute(df))
  as.character(sapply(table.list, FUN = function(x) x$filename)[df])
}

#' Convert data frame name to original table name.
#'
#' This function converts the internal data frame name as specified in
#' \code{table.list} to the original table name from SecuTrial
#' (e.g. emnphcvtreatments).
#' Either the name or the data frame directly is requeried.
#'
#' @param df data frame name or object
#' @return The original table name as defined in SecuTrial.
#' @export
df2tablename <- function(df) {
  table.list <- get("table.list") # declare variable since defined in dossier lib
  ## convert to character if object is provided
  if(typeof(df) != "character") df <- deparse(substitute(df))
  as.character(sapply(table.list, FUN = function(x) x$tablename)[df])
}

#' Convert file name to table name.
#'
#' This function converts the the filename in the export to the original table
#' name from SecuTrial' based on the mapping defined in \code{table.list}.
#'
#' @param file.name filename as in the SecuTrial export
#' @return The original table name as defined in SecuTrial.
#' @export
filename2tablename <- function(file.name) {
  table.list <- get("table.list") # declare variable since defined in dossier lib
  ## csv -> xls
  file.name <- gsub("csv", "xls", file.name)
  as.character(sapply(table.list, FUN = function(x) x$tablename)[which(sapply(table.list, FUN = function(x) x$filename) == file.name)])
}


